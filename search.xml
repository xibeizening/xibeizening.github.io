<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx使用时遇到的问题]]></title>
    <url>%2F2019%2F06%2F20%2Fnginx%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天nginx使用时，无法成功访问，查询日志发现问题 failed (1113: No mapping for the Unicode character exists in the target multi-byte code page) 解压的路径里面包含有中文的缘故，只要把解压后的文件剪切到没有包含中文的目录即可解决问题]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lombok插件在IDEA中的使用]]></title>
    <url>%2F2019%2F06%2F20%2Flombok%E6%8F%92%E4%BB%B6%E5%9C%A8IDEA%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[第一步：将插件安装在IDEA中 1安装步骤，选择File - &gt; setting - &gt; plugins，搜索lombok插件，选择安装 第二步：使用lombok，在pom文件中引入lombok的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 第三步：让其生效 选择File | Settings | Build, Execution, Deployment | Compiler | Annotation Processors勾选上]]></content>
      <categories>
        <category>lombok</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring框架入门学习之IOC和DI]]></title>
    <url>%2F2017%2F05%2F22%2Fspring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[spring概述 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 IOC理解：原本在程序中手动创建UserService对象的控制权交给spring框架管理，之所以叫控制反转，可理解为创建UserService对象控制权被反转到了Spring框架。 ＤI：依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件。 容器理解：spring将对象（new的service对象和new的dao对象）都放在容器中，以后用到时再取出，保证了对象都是同一个。 spring好处 1.方便解耦，简化开发:Spring就是一个大工厂，专门负责生成Bean，可以将所有对象创建和依赖关系维护由Spring管理。 2.AOP编程的支持:Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 3.声明式的事务支持:只需要通过配置就可以完成对事务的管理，而无需手动编程。 4.方便程序的测试:Spring对Junit4支持，可以通过注解方便的测试Spring程序 5.方便集成各种优秀框架:Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的支持。 6.降低JavaEE API的使用难度 Spring: 对JavaEE开发中一些难用的API（JDBC、JavaMail、远程调webservice用等），都提供了封装，使这些API应用难度大大降低。 spring快速入门之了解IOC第一步 下载spring包 第二步 准备项目所需的核心jar包导入4核心jar包(beans、core、context,expression)其位置在核心包的lib目录下，和1个依赖jar包(common-logging.jar)）其位置在依赖包的org.apache.commons目录下。并将所有的jar包放在一个springjars文件夹（名字随意）。 spring-core-3.2.2.RELEASE.jar 包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类,是其它组件的基本核心。 spring-beans-3.2.2.RELEASE.jar 所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control(IoC) / Dependency Injection(DI)操作相关的所有类 spring-context-3.2.2.RELEASE.jar Spring提供在基础IoC功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI定位、EJB集成、远程访问、缓存以及各种视图层框架的封装等。 spring-expression-3.2.2.RELEASE.jar Spring表达式语言 com.springsource.org.apache.commons.logging-1.1.1.jar 第三方的主要用于处理日志 第三步 在IDEA中创建spring项目 第四步 用以前的方式写个简单的Service 并在单元测试中调用1234567891011121314//简单的UserServicepublic class UserServiceImpl implements UserService &#123; @Override public void add() &#123; System.out.println("创建用户"); &#125;&#125;//测试调用@Test public void test1() &#123; //以前用service UserService userService = new UserServiceImpl(); userService.add(); &#125; 第五步 用spring IOC控制反转创建该UserService对象 在src目录下创建beans.xml配置文件，配置文件的约束可以访问开发文档spring-framework-3.2.0.RC2-docs/reference/html/xsd-config.html中查看1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- bean definitions here --&gt; &lt;!--配置一个bean对象--&gt; &lt;bean id="userService" class="service.UserServiceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 第六步 在单元测试中获取使用service即获取bean1234567//现在用UserService方式从spring容器中获取 //1.加载配置beans.xml文件,内部就会创建对象 ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"); //2.从spring容器获取userService对象 UserService userService = (UserService) context.getBean("userService"); userService1.add(); DI的作用 在UserService中提供一个get/set的name方法 在beans.xml中通过property去注入,即给name赋值 总结 如何下载spring的依赖包？还有网上说只发布spring-framework-3.0.2.RELEASE-dependencies.zip版本的依赖包，以后的版本都不在发布了。 从spring容器中获取的servic对象，获取相同的bean（bean即new好的对象）其地址都是一样的，获取的对象是同一个。其原因是，spring将对象都装在容器中，所以取出的对象也都是同一个，而以前new的对象，每当访问一个service时，便创建一个新的对象。]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA中创建JavaEE项目时JavaEE版本问题]]></title>
    <url>%2F2017%2F05%2F08%2F%E5%9C%A8IDEA%E4%B8%AD%E5%88%9B%E5%BB%BAJavaEE%E9%A1%B9%E7%9B%AE%E6%97%B6JavaEE%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题说明：IDEA中创建JavaEE项目时发现JavaEE版本没有8版本。经过一番查找问题终于解决了 问题的原因IDEA版本过低不支持JavaEE8版本 我的版本是IntelliJ IDEA 2017.2.6 x64 而使用JavaEE8版本需要IntelliJ IDEA 2017.3版本以上。更新IDEA后已经支持JavaEE8版本]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb实现分页功能]]></title>
    <url>%2F2017%2F05%2F01%2FJavaweb%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[实现分页功能有很多，这里用到的方法是使用sql语句实现分页功能 通过sql语句实现分页也是非常简单的，只是需要改变查询的语句就能实现了，即在sql语句后面添加limit分页语句。分页的思路效果图及分析如下 创建pageBean对象每次从后台拿那么多数据过来进行显示，所以我们就想办法把这些数据封装在一个javabean当中，每次后台都将查询到的数据放入javabean对象中，（使用异步请求获取该对象数据即可）只需要将该对象存入request作用域，然后在jsp页面中从域中获取需要的数据即可。1234567891011121314151617181920212223242526272829303132333435363738public class PageBean&lt;T&gt; &#123; private int totalCount;//总记录数 private int totalPage;//总页数 private int currentPage;//当前页码 private int pageSize;//每页显示的条数 private List&lt;T&gt; list;//每页显示的数据集合 public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; this.totalCount = totalCount; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getCurrentPage() &#123; return currentPage; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123; this.list = list; &#125;&#125; 在servlet中编写控制代码12345678910111213141516171819202122232425262728293031323334353637383940414243@WebServlet("/route/*")public class RouteServlet extends BaseServlet &#123; private RouteService routeService = new RouteServiceImpl(); /** * 分页查询 * @param request * @param response * @throws ServletException * @throws IOException */ public void pageQuery(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接受参数 String currentPageStr = request.getParameter("currentPage"); String pageSizeStr = request.getParameter("pageSize"); String cidStr = request.getParameter("cid"); int cid = 0;//类别id //2.处理参数 if(cidStr != null &amp;&amp; cidStr.length() &gt; 0)&#123; cid = Integer.parseInt(cidStr); &#125; int currentPage = 0;//当前页码，如果不传递，则默认为第一页 if(currentPageStr != null &amp;&amp; currentPageStr.length() &gt; 0)&#123; currentPage = Integer.parseInt(currentPageStr); &#125;else&#123; currentPage = 1; &#125; int pageSize = 0;//每页显示条数，如果不传递，默认每页显示5条记录 if(pageSizeStr != null &amp;&amp; pageSizeStr.length() &gt; 0)&#123; pageSize = Integer.parseInt(pageSizeStr); &#125;else&#123; pageSize = 5; &#125; //3. 调用service查询PageBean对象 PageBean&lt;Route&gt; pb = routeService.pageQuery(cid, currentPage, pageSize); //4. 将pageBean对象序列化为json，返回 writeValue(pb,response); &#125;&#125; 在service层中编写业务逻辑代码123456789101112131415161718192021222324252627public class RouteServiceImpl implements RouteService &#123; private RouteDao routeDao = new RouteDaoImpl(); @Override public PageBean&lt;Route&gt; pageQuery(int cid, int currentPage, int pageSize) &#123; //封装PageBean PageBean&lt;Route&gt; pb = new PageBean&lt;Route&gt;(); //设置当前页码 pb.setCurrentPage(currentPage); //设置每页显示条数 pb.setPageSize(pageSize); //设置总记录数 int totalCount = routeDao.findTotalCount(cid); pb.setTotalCount(totalCount); //设置当前页显示的数据集合 int start = (currentPage - 1) * pageSize;//开始的记录数 List&lt;Route&gt; list = routeDao.findByPage(cid,start,pageSize); pb.setList(list); //设置总页数 = 总记录数/每页显示条数 int totalPage = totalCount % pageSize == 0 ? totalCount / pageSize :(totalCount / pageSize) + 1 ; pb.setTotalPage(totalPage); return pb; &#125;&#125; 在Dao层编写sql语句查询数据库12345678910111213141516public class RouteDaoImpl implements RouteDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public int findTotalCount(int cid) &#123; String sql = "select count(*) from tab_route where cid = ?"; return template.queryForObject(sql,Integer.class,cid); &#125; @Override public List&lt;Route&gt; findByPage(int cid, int start, int pageSize) &#123; String sql = "select * from tab_route where cid = ? limit ? , ?"; return template.query(sql,new BeanPropertyRowMapper&lt;Route&gt;(Route.class),cid,start,pageSize); &#125;&#125; 在客户端代码的编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135$(function () &#123; var search = location.search; // 切割字符串，拿到第二个值 var cid = search.split("=")[1]; //当页码加载完成后，调用load方法，发送ajax请求加载数据 load(cid);&#125;);function load(cid ,currentPage)&#123; //发送ajax请求，请求route/pageQuery,传递cid $.get("route/pageQuery",&#123;cid:cid,currentPage:currentPage&#125;,function (pb) &#123; //解析pagebean数据，展示到页面上 //1.分页工具条数据展示 //1.1 展示总页码和总记录数 $("#totalPage").html(pb.totalPage); $("#totalCount").html(pb.totalCount); var lis = ""; var fristPage = '&lt;li onclick="javascipt:load('+cid+')"&gt;&lt;a href="javascript:void(0)"&gt;首页&lt;/a&gt;&lt;/li&gt;'; //计算上一页的页码 var beforeNum = pb.currentPage - 1; if(beforeNum &lt;= 0)&#123; beforeNum = 1; &#125; var beforePage = '&lt;li onclick="javascipt:load('+cid+','+beforeNum+')" class="threeword"&gt;&lt;a href="javascript:void(0)"&gt;上一页&lt;/a&gt;&lt;/li&gt;'; lis += fristPage; lis += beforePage; //1.2 展示分页页码 /* 1.一共展示10个页码，能够达到前5后4的效果 2.如果前边不够5个，后边补齐10个 3.如果后边不足4个，前边补齐10个 */ // 定义开始位置begin,结束位置 end var begin; // 开始位置 var end ; // 结束位置 //1.要显示10个页码 if(pb.totalPage &lt; 10)&#123; //总页码不够10页 begin = 1; end = pb.totalPage; &#125;else&#123; //总页码超过10页 begin = pb.currentPage - 5 ; end = pb.currentPage + 4 ; //2.如果前边不够5个，后边补齐10个 if(begin &lt; 1)&#123; begin = 1; end = begin + 9; &#125; //3.如果后边不足4个，前边补齐10个 if(end &gt; pb.totalPage)&#123; end = pb.totalPage; begin = end - 9 ; &#125; &#125; for (var i = begin; i &lt;= end ; i++) &#123; var li; //判断当前页码是否等于i if(pb.currentPage == i)&#123; li = '&lt;li class="curPage" onclick="javascipt:load('+cid+','+i+')"&gt;&lt;a href="javascript:void(0)"&gt;'+i+'&lt;/a&gt;&lt;/li&gt;'; &#125;else&#123; //创建页码的li li = '&lt;li onclick="javascipt:load('+cid+','+i+')"&gt;&lt;a href="javascript:void(0)"&gt;'+i+'&lt;/a&gt;&lt;/li&gt;'; &#125; //拼接字符串 lis += li; &#125; var lastPage = '&lt;li class="threeword"&gt;&lt;a href="javascript:;"&gt;末页&lt;/a&gt;&lt;/li&gt;'; var nextPage = '&lt;li class="threeword"&gt;&lt;a href="javascript:;"&gt;下一页&lt;/a&gt;&lt;/li&gt;'; lis += nextPage; lis += lastPage; //将lis内容设置到 ul $("#pageNum").html(lis); //2.列表数据展示 var route_lis = ""; for (var i = 0; i &lt; pb.list.length; i++) &#123; //获取&#123;rid:1,rname:"xxx"&#125; var route = pb.list[i]; var li = '&lt;li&gt;\n' + ' &lt;div class="img"&gt;&lt;img src="'+route.rimage+'" style="width: 299px;"&gt;&lt;/div&gt;\n' + ' &lt;div class="text1"&gt;\n' + ' &lt;p&gt;'+route.rname+'&lt;/p&gt;\n' + ' &lt;br/&gt;\n' + ' &lt;p&gt;'+route.routeIntroduce+'&lt;/p&gt;\n' + ' &lt;/div&gt;\n' + ' &lt;div class="price"&gt;\n' + ' &lt;p class="price_num"&gt;\n' + ' &lt;span&gt;&amp;yen;&lt;/span&gt;\n' + ' &lt;span&gt;'+route.price+'&lt;/span&gt;\n' + ' &lt;span&gt;起&lt;/span&gt;\n' + ' &lt;/p&gt;\n' + ' &lt;p&gt;&lt;a href="route_detail.html"&gt;查看详情&lt;/a&gt;&lt;/p&gt;\n' + ' &lt;/div&gt;\n' + ' &lt;/li&gt;'; route_lis += li; &#125; $("#route").html(route_lis); //定位到页面顶部 window.scrollTo(0,0); &#125;);&#125; 注意 在Dao层使用sql查询数据库时，需查总记录数和分页查询 pageBean中用到泛型，以后亦可使用，此处中放的泛型是旅游线路商品实体类（即分页中要展示的数据）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>pageBean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化servlet，抽取BaseServlet]]></title>
    <url>%2F2017%2F04%2F28%2F%E4%BC%98%E5%8C%96servlet%EF%BC%8C%E6%8A%BD%E5%8F%96BaseServlet%2F</url>
    <content type="text"><![CDATA[优化servlet的目的：减少Servlet的数量，现在是一个功能一个Servlet，将其优化为一个模块一个Servlet，相当于在数据库中一张表对应一个Servlet，在Servlet中提供不同的方法，完成用户的请求。（UserServlet作为例子，其中的方法就是优化前的登录的servlet，注册的servlet,激活的servlet,退出的servlet） BaseServlet的原理BaseServlet继承HTTPServlet,UserServlet继承BaseServlet。BaseServlet重写HTTPServlet中的service方法，在service方法中实现方法的分发。从而实现UserServlet中的方法（其中的方法就是优化前的servlet） 具体实现 BaseServlet的编写 12345678910111213141516171819202122232425 //@WebServlet("/BaseServlet")由于BaseServlet不会被访问，所以不用添加注解配置虚拟路径public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //完成方法分发 //1.获取请求路径 String uri = req.getRequestURI(); // /travel/user/add //2.获取方法名称 String methodName = uri.substring(uri.lastIndexOf('/') + 1); //3.获取方法对象Method //谁调用我？我代表谁 try &#123; //获取方法,注意要获取的UserServlet中的方法的权限不能为protected Method method = this.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); //4.执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; UserServlet的编写 12345678910@WebServlet(&quot;/user/*&quot;)其访问路径为//user/add或者/user/findpublic class UserServlet extends BaseServlet &#123; private void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; private void find(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 细节 1.由于 UserServlet extends BaseServlet，所以在访问UserServlet时即实现了BaseServlet中的service方法。 2.BaseServlet不需要访问所以不用添加访问路径的注解。 3.UserServlet的访问路径中的通配符所代表的就是Userservlet中的方法，也是通过该访问路径，获得执行方法的方法名，方法对象，进而执行该方法。 4.UserServlet的方法的权限为public。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的向标签动态写入方法]]></title>
    <url>%2F2017%2F04%2F22%2FjQuery%E7%9A%84%E5%86%99%E5%85%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[偶然发现jQuery的html方法是替换，由此做个动态写入的方法总结 jQuery动态写入的方法我了解到有两种 $(“选择器”).html(“写入内容”);此方法会将原来的内容替换覆盖掉。 $(“选择器”).append(“写入内容”);此方法会将新内容添加到原有内容之后。 关于JS的动态写入方法（我不打算学-。-）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis笔记]]></title>
    <url>%2F2017%2F04%2F19%2Fredis%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概念redis是一款高性能的NOSQL系列的非关系型数据库。 NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。优缺点优点 1）成本低，nosql数据库简单易部署，基本都是开源软件，相比关系型数据库价格更加便宜 2）查询速度快：因为nosql数据库将数据存储在缓存中，关系型数据库将数据存储在硬盘中，查询速度相比之下快得多。 3）存储数据的格式：nosql存储数据的格式是以key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 redis简介什么是Redis？ Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 下载安装1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 命令操作 redis的数据结构： redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构。 value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 1.字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 2. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 3. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 4. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 5. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 6. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 持久化1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 Java客户端 JedisJedis: 一款java操作redis数据库的工具. 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); jedis连接池： JedisPool* 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool (config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } }]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session技术回顾]]></title>
    <url>%2F2017%2F04%2F11%2FSession%E6%8A%80%E6%9C%AF%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[今天遇到使用Session会话技术获取不到数据的问题，所以重新温习下Session会话技术。主要的问题就是我没有在session中保存数据，导致取不到数据。 1.Session：1.概念：服务器会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器的对象中。HTTPSession 2.HTTPSession对象中的方法： Object getAttribute(String name) void setAttribute(String name,Object value) void removeAttribute(String name) 3.使用Session共享数据的基本步骤：第一步获取session对象（使用方法request.getSession(),该方法返回一个HTTPSession对象），第二步存储数据setAttribute(String name,Object value)，第三步在另一个servlet中获取数据（先获取HTTPSession对象,再用getAttribute(String name)获取数据） 2.服务器如何确保在一次会话范围内，多次获取的Session对象是同一个？ Session的实现是依赖于Cookie的，在第一次使用request.getSession()方法获取HTTPSession对象时，没有Cookie,会在内存中创建一个新的HTTPSession对象，并且在响应请求时会设置一个JSESSIONID的值，在一次会话中，该值的作用是，当再次获取HTTPSession对象时为同一个对象。 3.Session细节1.当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ 默认情况下，不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 2.客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化(服务器关闭后，会在work目录下创建一个名为SESSION的文件)： 在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化：(IDEA中不会活化，在重新启动后，会直接将work目录删除掉，在重新构建而tomcat服务器不会) 在服务器启动后，将session文件转化为内存中的session对象即可。 3.session什么时候被销毁？ 1.服务器关闭 2.session对象调用invalidate() 。 3.session默认失效时间 30分钟 选择性配置修改（在tomcat的conf下的web.xml配置文件中） 123 &lt;session-config&gt;&lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 4.特点1.session用于存储一次会话的多次请求的数据，存在服务器端。 2.session可以存储任意类型，任意大小的数据。 session与cookie的区别 1. session存储数据在服务器端，Cookie在客户端。 2. session没有数据大小限制，Cookie有。 3. session数据安全，Cookie相对于不安全。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目中关于设置JDK版本的问题]]></title>
    <url>%2F2017%2F04%2F02%2FIDEA%EF%BC%8Cmaven%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%AE%BE%E7%BD%AEJDK%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[maven项目中遇到的情况。 情况说明1：maven中设置的JDK版本是1.8，IDEA中配置的JDK是9版本，运行配置的是Use project settings，运行时用JDK9编译。 情况说明2：maven中设置不变，IDEA中配置的JDK时1.8版本,运行配置的是Use project settings，运行时用JDK9编译。 情况说明3：maven中设置不变，IDEA中配置的JDK时1.8版本,运行配置的是不勾选Use project settings，具体细节看图，运行时用JDK1.8编译。 情况说明4：maven中设置不变，IDEA中配置的JDK时1.8版本,运行配置的是不勾选Use project settings，具体细节看图，运行时用JDK9编译。 情况1详细说明 1.使用的开发工具是IDEA，其中maven项目部署中的pom.xml文件设置的jdk编译插件是1.8。 12345678910&lt;!--jdk编译插件--&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; 2.IDEA配置的JDK是9版本 3.运行配置 4.编译结果显示的版本 D:\Java\jdk-9.0.1 情况2详细说明 1.pom.xml文件不变 2.IDEA配置的JDK是1.8版本 3.运行配置 4.编译结果显示的版本 D:\Java\jdk-9.0.1 情况3详细说明 1.pom.xml文件不变 2.IDEA配置的JDK是1.8版本 3.运行配置 4.编译结果显示的版本 D:\Java\jdk1.8.0_131 情况4详细说明 1.pom.xml文件不变 2.IDEA配置的JDK是1.8版本 3.运行配置 4.编译结果显示的版本 D:\Java\jdk1.8.0_131 问题总结 1.maven项目中pom.xml的JDK的设置是否有用？ 2.排除pom.xml中的配置，运行配置中的Use project settings有何用处？ 3.项目设置JDK版本为何无效用？ 4.由情况3和情况4比较可得出maven项目中JDK的编译版本的决定因素是运行配置中选取哪一个版本的JRE决定！ 问题未解决]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[概述异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 体系异常机制其实是帮助我们找到程序中的问题，异常的根类是 java.lang.Throwable ，其下有两个子类：java.lang.Error 与 java.lang.Exception ，平常所说的异常指java.lang.Exception 。Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace() :打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage() :获取发生异常的原因。提示给用户的时候,就提示错误原因。 public String toString() :获取异常的类型和异常描述信息(不用)。 异常分类异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： throw new 异常类名(参数); 例如： throw new NullPointerException(&quot;要访问的arr数组不存在&quot;); throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;); 声明异常声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ } 捕获异常捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： try{ 编写可能会出现异常的代码 }catch(异常类型 e){ 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 } finally代码块]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map集合]]></title>
    <url>%2F2017%2F03%2F15%2FMap%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[概述1.Collection 中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 2.Map 中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的 值。 3.Collection 中的集合称为单列集合， Map 中的集合称为双列集合。 4.需要注意的是， Map 中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 Map集合常用子类 HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。 Map接口中的常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。 public V remove(Object key) : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 public Set&lt;K&gt; keySet() : 获取Map集合中所有的键，存储到Set集合中。 public Set&lt; Map.Entry &lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map集合遍历键找值方式键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 1. 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示: keyset() 2. 遍历键的Set集合，得到每一个键。 3. 根据键，获取键所对应的值。方法提示: get(K key) 代码演示： 12345678910111213141516171819public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //添加元素到集合 map.put("胡歌", "霍建华"); map.put("郭德纲", "于谦"); map.put("薛之谦", "大张伟"); //获取所有的键 获取键集 Set&lt;String&gt; keys = map.keySet(); // 遍历键集 得到 每一个键 for (String key : keys) &#123; //key 就是键 //获取对应值 String value = map.get(key); System.out.println(key+"的CP是："+value); &#125; &#125;&#125; Entry键值对对象我们已经知道， Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在 Map 中是一一对应关系，这一对对象又称做 Map 中的一个 Entry(项) 。Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey() ：获取Entry对象中的键。 public V getValue() ：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 1. 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示: entrySet() 。 2. 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 3. 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示: getkey() getValue() 12345678910111213141516171819public class MapDemo02 &#123; public static void main(String[] args) &#123; // 创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); // 添加元素到集合 map.put("胡歌", "霍建华"); map.put("郭德纲", "于谦"); map.put("薛之谦", "大张伟"); // 获取 所有的 entry对象 entrySet Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); // 遍历得到每一个entry对象 for (Entry&lt;String, String&gt; entry : entrySet) &#123; // 解析 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"的CP是:"+value); &#125; &#125;&#125; LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 123456789101112public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put("邓超", "孙俪"); map.put("李晨", "范冰冰"); map.put("刘德华", "朱丽倩"); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + " " + entry.getValue()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List接口，Set接口]]></title>
    <url>%2F2017%2F03%2F14%2FList%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[List接口java.util.List 接口继承自 Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了 List 接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 常用方法public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。 public E get(int index) :返回集合中指定位置的元素。 public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合的子类ArrayList集合java.util.ArrayList 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以 ArrayList 是最常用的集合。 LinkedList集合java.util.LinkedList 集合数据存储的结构是链表结构。方便元素添加、删除的集合。 Set接口java.util.Set 接口和 java.util.List 接口一样，同样继承自 Collection 接口，它与 Collection 接口中的方法基本一致，并没有对 Collection 接口进行功能上的扩充，只是比 Collection 接口更加严格了。与 List 接口不同的是， Set 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set 集合有多个子类，这里我们介绍其中的 java.util.HashSet 、 java.util.LinkedHashSet 这两个集合。 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。 而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 LinkedHashSet集合我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？在HashSet下面有一个子类 java.util.LinkedHashSet ，它是链表和哈希表组合的一个数据存储结构。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2017%2F03%2F13%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add("abc"); coll.add("itcast"); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。为什么会发生类型转换异常呢？我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。怎么来解决这个问题呢？Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 泛型的好处 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc"); list.add("itcast"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection集合，迭代器，增强for循环]]></title>
    <url>%2F2017%2F03%2F13%2FCollection%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合概述前面学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储 迭代器在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 1234567//使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; 增强for循环增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装类]]></title>
    <url>%2F2017%2F03%2F12%2F%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System类、StringBuilder类]]></title>
    <url>%2F2017%2F03%2F12%2FSystem%E7%B1%BB%E3%80%81StringBuilder%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 arraycopy中五个参数的含义 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 StringBuilder类概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 常用方法 public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 备注：StringBuilder已经覆盖重写了Object当中的toString方法。]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类、 Date类]]></title>
    <url>%2F2017%2F03%2F12%2FObject%E7%B1%BB%E3%80%81-Date%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。如果一个类没有特别指定父类， 那么默认则继承自Object类。 toString和equals方法 public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。Data类（日期时间） 概述java.util.Date类 表示特定的瞬间，精确到毫秒。 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final、权限、内部类、接口引用类型]]></title>
    <url>%2F2017%2F03%2F11%2Ffinal%E3%80%81%E6%9D%83%E9%99%90%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[final关键字Java提供了 final 关键字，用于修饰不可改变内容。 final： 不可改变。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 权限修饰符在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， public：公共的。 protected：受保护的 default：默认的 private：私有的 public protected default（空的） private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 内部类概述将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类1234class 外部类 &#123; class 内部类&#123; &#125;&#125; 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 匿名内部类【重点】概述匿名内部类 ：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作， 1. 定义子类 2. 重写接口中的方法 3. 创建子类对象 4. 调用重写后的方法 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。 前提匿名内部类必须继承一个父类或者实现一个父接口。 格式new1234567父类或者接口名 变量名 = new 父类父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 接口作为引用类型接口作为参数时，传递它的子类对象。 接口作为返回值类型时，返回它的子类对象。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口，多态]]></title>
    <url>%2F2017%2F03%2F10%2F%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[接口概述接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9） 定义格式123456public interface 接口名称 &#123; // 抽象方法 // 默认方法 // 静态方法 // 私有方法&#125; 基本实现类与接口的关系为实现关系，即类实现接口。 该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。 非抽象子类实现接口： 1. 必须重写接口中所有抽象方法。 2. 继承了接口的默认方法，即可以直接调用，也可以重写。 多态概述是指同一行为，具有多个不同表现形式，就是同一个接口，使用不同的实例而执行不同操作 多态体现的格式：父类类型 变量名 = new 子类对象； 变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 多态之接口指向实现类对象Result接口，他的实现类是ResultImp 会有这样的操作：Result result = new ResultImp(); 这样做的好处，使用子类却不依赖于子类。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承，super和this关键字，抽象类]]></title>
    <url>%2F2017%2F03%2F09%2F%E7%BB%A7%E6%89%BF%EF%BC%8Csuper%EF%BC%8Cthis%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[继承继承概述 就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 is-a的关系，例如狮子是一个动物。 1. 提高代码的复用性。 2. 类与类之间产生了关系，是多态的前提 继承格式 通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 123456class 父类 &#123; ...&#125;class 子类 extends 父类 &#123; ...&#125; 继承后的特点继承后成员变量 继承后子类和父类的变量不重名时，子类可直接访问父类和自己的变量 继承后子类和父类的变量重名时，子类访问自己和父类的变量时采取就近原则，访问的都是子类的变量。重名时，如若要访问父类的变量，需要加super关键字，即super.父类变量名。（储存空间标识，代表父亲的引用）类似于this，而this关键字代表对象自己的引用（谁调用就代表谁） 继承后成员方法 如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 重写的应用：子类可以根据需要，定义特定于自己的行为。 重写需注意的地方： 1. 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 2. 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 继承后构造方法 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。 访问构造方法： this( ) //本类的构造方法 super( ) // 父类的构造方法 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 继承的方式 Java只支持单继承，不支持多继承。 123//一个类只能有一个父类，不可以有多个父类。class C extends A&#123;&#125; //okclass C extends A，B... //error Java支持多层继承(继承体系)。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; 顶层父类是Object类。所有的类默认继承Object，作为父类。子类和父类是一种相对的概念。 super和this关键字super ：代表父类的存储空间标识(可以理解为父亲的引用)。 this ：代表当前对象的引用(谁调用就代表谁)。 抽象类概述 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 定义 抽象方法 ： 没有方法体的方法。public abstract void run(); 抽象类：包含抽象方法的类。abstract class 类名字 {抽象方法} 如果一个类包含抽象方法，那么该类必须是抽象类。 抽象的使用 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 注意事项 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类、static关键字、Arrays类、 Math类]]></title>
    <url>%2F2017%2F03%2F08%2FString%E7%B1%BB%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81Arrays%E7%B1%BB%E3%80%81-Math%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[String类 java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。 类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。 特点：1. 字符串不变：字符串的值在创建后不能被更改。 2. 因为String对象是不可变的，所以它们可以被共享。 3. &quot;abc&quot; 等效于 char[] data={ &apos;a&apos; , &apos;b&apos; , &apos;c&apos; } 4. String是一个内置对象，java已经帮我们new了。 String s1 = &quot;hello&quot;; String s1 = new String(&quot;hello&quot;); 常用方法判断功能的方法 public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。 public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写。 获取功能的方法 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。 转换功能的方法 public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 分割功能的方法 public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 static关键字 关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 类变量 当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 静态方法 当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。 静态代码块静态代码块：定义在成员位置，使用static修饰的代码块{ }。 位置：类中方法外。 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。 12345public class ClassName&#123;static &#123;// 执行语句&#125;&#125; static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。 Arrays类概述：java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 操作数组的方法： public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 Math类概述：java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 public static double abs(double a) ：返回 double 值的绝对值。 public static double ceil(double a) ：返回大于等于参数的最小的整数。 public static double floor(double a) ：返回小于等于参数最大的整数。 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API概述，Scanner类，Random类，ArrayList 类]]></title>
    <url>%2F2017%2F03%2F07%2FAPI%E6%A6%82%E8%BF%B0%EF%BC%8CScanner%E7%B1%BB%EF%BC%8CRandom%E7%B1%BB%EF%BC%8CArrayList-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[API概述API(Application Programming Interface)，应用程序编程接口。 Java API是一本程序员的字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。 Scanner类概述：Scanner类是一个可以解析基本类型和字符串的简单文本扫描器。12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); Random类概述：此类的实例用于生成伪随机数。123Random r = new Random();int i = r.nextInt();//生成随机数int i = r.nextInt();//生成指定范围的随机数 ArrayList集合类概述：java.util.ArrayList &lt; E &gt; 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。 只能是引用类型&lt; E &gt; ，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。 ArrayList集合类常用方法和遍历对于元素的操作,基本体现在——增、删、查。常用的方法有： public boolean add(E e) ：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 如何存储基本数据类型？ ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 &lt; int &gt; 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt; &gt; 中的数据类型，必须转换后才能编写，转换写法如下： 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer 和 Character 需要特殊记忆，其他基本类型只是首字母大写即可]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类与对象，成员变量与局部变量，封装]]></title>
    <url>%2F2017%2F03%2F06%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%81%E8%A3%85%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[类与对象什么是类类：（成员变量，成员方法，对应属性和行为）是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。 现实中，描述一类事物： 属性：就是该事物的状态信息。 行为：就是该事物能够做什么。 举例：小猫。 属性：名字、体重、年龄、颜色。 行为：走、跑、叫。 什么是对象对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。 现实中，一类事物的一个实例：一只小猫。 举例：一只小猫。 属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。 使用格式：类名 对象名 = new 类名(); 类与对象的关系类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 成员变量与局部变量的区别 在类中的位置不同 重点 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 重点 成员变量：类中 局部变量：方法中 初始化值的不同 重点 成员变量：有默认值 局部变量：没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 了解 成员变量：堆内存 局部变量：栈内存 生命周期不同 了解 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 封装 概述：封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 封装的步骤1. 使用 private 关键字来修饰成员变量。 2. 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。 封装优化之this关键字与构造方法 this代表所在类的当前对象的引用（地址值），即对象自己的引用。 当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。 标准代码——JavaBeanJavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组，jvm虚拟机内存划分]]></title>
    <url>%2F2017%2F03%2F05%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组的三种定义方式 第一种：数组存储的数据类型[ ] 数组名字 = new 数组存储的数据类型[长度];int[] arr = new int[3]; 第二种：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3…};int[] arr = new int[]{1,2,3,4,5}; 第三种：数据类型[] 数组名 = {元素1,元素2,元素3…};int[] arr = {1,2,3,4,5}; JVM的内存划分 区域名称 作用 寄存器 给CPU使用，和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组，new来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流程控制结构，方法重载]]></title>
    <url>%2F2017%2F03%2F04%2F%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[流程控制结构顺序结构 顾名思义从上到下执行 选择结构 if选择语句 if...else...选择语句 if...else if...else if...else选择语句 switch...选择语句 循环结构 for循环语句 while循环语句 do...while循环语句 方法重载 指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 参数列表：个数不同，数据类型不同，顺序不同。 重载方法调用：JVM通过方法的参数列表，调用不同的方法。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三元运算符，方法]]></title>
    <url>%2F2017%2F03%2F03%2F%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E6%96%B9%E6%B3%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[三元运算符格式：三元运算符格式： 数据类型 变量名 = 布尔类型表达式？结果1：结果2 三元运算符计算方式： 布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。 布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 方法入门 方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 定义格式：1234修饰符 返回值类型 方法名 （参数列表）｛代码...return ;｝ 方法定义注意事项：方法学定义完成需在主方法中调用，方可使用。 方法必须定义在一类中方法外。 方法不能定义在另一个方法的里面。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型，数据类型转换]]></title>
    <url>%2F2017%2F03%2F02%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据类型四类：整型，浮点，字符，布尔 八种基本数据类型（Java中的默认类型：整数类型是 int 、浮点类型是 double 。） 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int 4个字节 -2的31次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 ﬂoat 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认） 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false 自动转换Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。一个 int 类型变量和一个 byte 类型变量进行加法运算， 结果会是什么数据类型？12int i = 1; byte b = 2; 运算结果，变量的类型将是 int 类型，这就是出现了数据类型的自动类型转换现象。该类型转换的原理：byte类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类 型。 转换规则范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换将 1.5 赋值到 int 类型变量会发生什么？产生编译失败，肯定无法赋值。1int i = 1.5; // 错误 double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。可以理解为 double 是8升的水壶， int 是4升的水壶，不能把大水壶中的水直接放进小水壶去。想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。 转换格式： 数据类型 变量名 = （数据类型）被转数据值; 将 1.5 赋值到 int 类型，代码修改为： //double类型数据强制转成int类型 int i = (int)1.5; 同样道理，当一个 short 类型与 1 相加，我们知道会类型提升，但是还想给结果赋值给short类型变量，就需要强制转换。12345678910111213public static void main(String[] args) &#123;//short类型变量，内存中2个字节short s = 1;/*出现编译失败s和1做运算的时候，1是int类型，s会被提升为int类型s+1后的结果是int类型，将结果在赋值会short类型时发生错误short内存2个字节，int类型4个字节必须将int强制转成short才能完成赋值*/s = s + 1；//编译失败s = (short)(s+1);//编译成功&#125; 浮点转成整数，直接取掉小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失。 强制转换规则 强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节，常用DOS命令，Java简介，标识符命名规则]]></title>
    <url>%2F2017%2F03%2F01%2F%E5%AD%97%E8%8A%82%E4%B8%8E%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[字节字节是我们常见的计算机中小存储单元。计算机存储任何的数据，都是以字节的形式存储。 二进制数系统中，每个0或1就是一个位，叫做bit（比特）。 8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。 8 bit = 1 B 1024 B =1 KB 1024 KB =1 MB 1024 MB =1 GB 1024 GB = 1 TB 常用DOS命令盘符切换命令 盘符名: 查看当前文件夹 dir 进入文件夹命令 cd 文件夹名 退出文件夹命令 cd.. 退出到磁盘根目录 cd\ 清屏 cls Java简介 JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 环境变量的配置JAVA_HOME=%安装路径%\Java\jdk path=%JAVA_HOME%\bin 标识符命名规则标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 命名规则： 硬性要求 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 标识符不能以数字开头。 标识符不能是关键字。 命名规范： 软性建议 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 变量名规范：全部小写。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
</search>
